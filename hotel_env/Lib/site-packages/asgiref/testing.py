import asyncio 
import contextvars 
import time 

from .compatibility import guarantee_single_callable 
from .timeout import timeout as async_timeout 


class ApplicationCommunicator :
    """
    Runs an ASGI application in a test mode, allowing sending of
    messages to it and retrieval of messages it sends.
    """

    def __init__ (self ,application ,scope ):
        self ._future =None 
        self .application =guarantee_single_callable (application )
        self .scope =scope 
        self ._input_queue =None 
        self ._output_queue =None 



    @property 
    def input_queue (self ):
        if self ._input_queue is None :
            self ._input_queue =asyncio .Queue ()
        return self ._input_queue 

    @property 
    def output_queue (self ):
        if self ._output_queue is None :
            self ._output_queue =asyncio .Queue ()
        return self ._output_queue 

    @property 
    def future (self ):
        if self ._future is None :




            self ._future =contextvars .Context ().run (
            asyncio .create_task ,
            self .application (
            self .scope ,self .input_queue .get ,self .output_queue .put 
            ),
            )
        return self ._future 

    async def wait (self ,timeout =1 ):
        """
        Waits for the application to stop itself and returns any exceptions.
        """
        try :
            async with async_timeout (timeout ):
                try :
                    await self .future 
                    self .future .result ()
                except asyncio .CancelledError :
                    pass 
        finally :
            if not self .future .done ():
                self .future .cancel ()
                try :
                    await self .future 
                except asyncio .CancelledError :
                    pass 

    def stop (self ,exceptions =True ):
        future =self ._future 
        if future is None :
            return 

        if not future .done ():
            future .cancel ()
        elif exceptions :

            future .result ()

    def __del__ (self ):

        try :
            self .stop (exceptions =False )
        except RuntimeError :

            pass 

    async def send_input (self ,message ):
        """
        Sends a single message to the application
        """

        if self .future .done ():
            self .future .result ()


        await self .input_queue .put (message )

    async def receive_output (self ,timeout =1 ):
        """
        Receives a single message from the application, with optional timeout.
        """

        if self .future .done ():
            self .future .result ()

        try :
            async with async_timeout (timeout ):
                return await self .output_queue .get ()
        except asyncio .TimeoutError as e :

            if self .future .done ():
                self .future .result ()
            else :
                self .future .cancel ()
                try :
                    await self .future 
                except asyncio .CancelledError :
                    pass 
            raise e 

    async def receive_nothing (self ,timeout =0.1 ,interval =0.01 ):
        """
        Checks that there is no message to receive in the given time.
        """

        if self .future .done ():
            self .future .result ()


        start =time .monotonic ()
        while time .monotonic ()-start <timeout :
            if not self .output_queue .empty ():
                return False 
            await asyncio .sleep (interval )
        return self .output_queue .empty ()
