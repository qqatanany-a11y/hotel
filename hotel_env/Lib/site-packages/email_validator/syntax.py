from .exceptions import EmailSyntaxError 
from .types import ValidatedEmail 
from .rfc_constants import EMAIL_MAX_LENGTH ,LOCAL_PART_MAX_LENGTH ,DOMAIN_MAX_LENGTH ,DOT_ATOM_TEXT ,DOT_ATOM_TEXT_INTL ,ATEXT_RE ,ATEXT_INTL_DOT_RE ,ATEXT_HOSTNAME_INTL ,QTEXT_INTL ,DNS_LABEL_LENGTH_LIMIT ,DOT_ATOM_TEXT_HOSTNAME ,DOMAIN_NAME_REGEX ,DOMAIN_LITERAL_CHARS 

import re 
import unicodedata 
import idna 
import ipaddress 
from typing import Optional ,Tuple ,TypedDict ,Union 


def split_email (email :str )->Tuple [Optional [str ],str ,str ,bool ]:



































    def split_string_at_unquoted_special (text :str ,specials :Tuple [str ,...])->Tuple [str ,str ]:




        inside_quote =False 
        escaped =False 
        left_part =""
        for i ,c in enumerate (text ):





            if unicodedata .normalize ("NFC",text [i :])[0 ]!=c :
                left_part +=c 

            elif inside_quote :
                left_part +=c 
                if c =='\\'and not escaped :
                    escaped =True 
                elif c =='"'and not escaped :

                    inside_quote =False 
                    escaped =False 
                else :
                    escaped =False 
            elif c =='"':
                left_part +=c 
                inside_quote =True 
            elif c in specials :

                break 
            else :
                left_part +=c 




        if len (left_part )==len (text ):








            if "＠"in text :
                raise EmailSyntaxError ("The email address has the \"full-width\" at-sign (@) character instead of a regular at-sign.")





            if "﹫"in text :
                raise EmailSyntaxError ('The email address has the "small commercial at" character instead of a regular at-sign.')

            raise EmailSyntaxError ("An email address must have an @-sign.")


        right_part =text [len (left_part ):]

        return left_part ,right_part 

    def unquote_quoted_string (text :str )->Tuple [str ,bool ]:




        quoted =False 
        escaped =False 
        value =""
        for i ,c in enumerate (text ):
            if quoted :
                if escaped :
                    value +=c 
                    escaped =False 
                elif c =='\\':
                    escaped =True 
                elif c =='"':
                    if i !=len (text )-1 :
                        raise EmailSyntaxError ("Extra character(s) found after close quote: "
                        +", ".join (safe_character_display (c )for c in text [i +1 :]))
                    break 
                else :
                    value +=c 
            elif i ==0 and c =='"':
                quoted =True 
            else :
                value +=c 

        return value ,quoted 


    left_part ,right_part =split_string_at_unquoted_special (email ,("@","<"))





    if right_part .startswith ("<"):

        left_part =left_part .rstrip ()


        display_name ,display_name_quoted =unquote_quoted_string (left_part )



        if not display_name_quoted :
            bad_chars ={
            safe_character_display (c )
            for c in display_name 
            if (not ATEXT_RE .match (c )and c !=' ')or c =='.'
            }
            if bad_chars :
                raise EmailSyntaxError ("The display name contains invalid characters when not quoted: "+", ".join (sorted (bad_chars ))+".")


        check_unsafe_chars (display_name ,allow_space =True )



        if ">"not in right_part :
            raise EmailSyntaxError ("An open angle bracket at the start of the email address has to be followed by a close angle bracket at the end.")
        right_part =right_part .rstrip (" ")
        if right_part [-1 ]!=">":
            raise EmailSyntaxError ("There can't be anything after the email address.")


        addr_spec =right_part [1 :].rstrip (">")


        local_part ,domain_part =split_string_at_unquoted_special (addr_spec ,("@",))



    else :
        display_name =None 
        local_part ,domain_part =left_part ,right_part 

    if domain_part .startswith ("@"):
        domain_part =domain_part [1 :]


    local_part ,is_quoted_local_part =unquote_quoted_string (local_part )

    return display_name ,local_part ,domain_part ,is_quoted_local_part 


def get_length_reason (addr :str ,limit :int )->str :
    """Helper function to return an error message related to invalid length."""
    diff =len (addr )-limit 
    suffix ="s"if diff >1 else ""
    return f"({diff} character{suffix} too many)"


def safe_character_display (c :str )->str :

    if c =='\\':
        return f"\"{c}\""
    if unicodedata .category (c )[0 ]in ("L","N","P","S"):
        return repr (c )


    if ord (c )<0xFFFF :
        h =f"U+{ord(c):04x}".upper ()
    else :
        h =f"U+{ord(c):08x}".upper ()


    return unicodedata .name (c ,h )


class LocalPartValidationResult (TypedDict ):
    local_part :str 
    ascii_local_part :Optional [str ]
    smtputf8 :bool 


def validate_email_local_part (local :str ,allow_smtputf8 :bool =True ,allow_empty_local :bool =False ,
quoted_local_part :bool =False ,strict :bool =False )->LocalPartValidationResult :
    """Validates the syntax of the local part of an email address."""

    if len (local )==0 :
        if not allow_empty_local :
            raise EmailSyntaxError ("There must be something before the @-sign.")



        return {
        "local_part":local ,
        "ascii_local_part":local ,
        "smtputf8":False ,
        }








    if strict and len (local )>LOCAL_PART_MAX_LENGTH :
        reason =get_length_reason (local ,limit =LOCAL_PART_MAX_LENGTH )
        raise EmailSyntaxError (f"The email address is too long before the @-sign {reason}.")








    if DOT_ATOM_TEXT .match (local ):






        return {
        "local_part":local ,
        "ascii_local_part":local ,
        "smtputf8":False ,
        }





    valid :Optional [str ]=None 
    requires_smtputf8 =False 
    if DOT_ATOM_TEXT_INTL .match (local ):

        if not allow_smtputf8 :



            bad_chars ={
            safe_character_display (c )
            for c in local 
            if not ATEXT_RE .match (c )
            }
            if bad_chars :
                raise EmailSyntaxError ("Internationalized characters before the @-sign are not supported: "+", ".join (sorted (bad_chars ))+".")


            raise EmailSyntaxError ("Internationalized characters before the @-sign are not supported.")


        valid ="dot-atom"
        requires_smtputf8 =True 





    elif quoted_local_part :




        bad_chars ={
        safe_character_display (c )
        for c in local 
        if not QTEXT_INTL .match (c )
        }
        if bad_chars :
            raise EmailSyntaxError ("The email address contains invalid characters in quotes before the @-sign: "+", ".join (sorted (bad_chars ))+".")


        bad_chars ={
        safe_character_display (c )
        for c in local 
        if not (32 <=ord (c )<=126 )
        }
        if bad_chars :
            requires_smtputf8 =True 


            if not allow_smtputf8 :
                raise EmailSyntaxError ("Internationalized characters before the @-sign are not supported: "+", ".join (sorted (bad_chars ))+".")


        valid ="quoted"



    if valid :





        check_unsafe_chars (local ,allow_space =(valid =="quoted"))




        try :
            local .encode ("utf8")
        except ValueError as e :
            raise EmailSyntaxError ("The email address contains an invalid character.")from e 





        if valid =="quoted":
            local ='"'+re .sub (r'(["\\])',r'\\\1',local )+'"'

        return {
        "local_part":local ,
        "ascii_local_part":local if not requires_smtputf8 else None ,
        "smtputf8":requires_smtputf8 ,
        }







    bad_chars ={
    safe_character_display (c )
    for c in local 
    if not ATEXT_INTL_DOT_RE .match (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The email address contains invalid characters before the @-sign: "+", ".join (sorted (bad_chars ))+".")



    check_dot_atom (local ,'An email address cannot start with a {}.','An email address cannot have a {} immediately before the @-sign.',is_hostname =False )



    raise EmailSyntaxError ("The email address contains invalid characters before the @-sign.")


def check_unsafe_chars (s :str ,allow_space :bool =False )->None :


    bad_chars =set ()
    for i ,c in enumerate (s ):
        category =unicodedata .category (c )
        if category [0 ]in ("L","N","P","S"):

            pass 
        elif category [0 ]=="M":




            if i ==0 :
                bad_chars .add (c )
        elif category =="Zs":









            if not allow_space :
                bad_chars .add (c )
        elif category [0 ]=="Z":




            bad_chars .add (c )
        elif category [0 ]=="C":







            bad_chars .add (c )
        else :


            bad_chars .add (c )
    if bad_chars :
        raise EmailSyntaxError ("The email address contains unsafe characters: "
        +", ".join (safe_character_display (c )for c in sorted (bad_chars ))+".")


def check_dot_atom (label :str ,start_descr :str ,end_descr :str ,is_hostname :bool )->None :

    if label .endswith ("."):
        raise EmailSyntaxError (end_descr .format ("period"))
    if label .startswith ("."):
        raise EmailSyntaxError (start_descr .format ("period"))
    if ".."in label :
        raise EmailSyntaxError ("An email address cannot have two periods in a row.")

    if is_hostname :

        if label .endswith ("-"):
            raise EmailSyntaxError (end_descr .format ("hyphen"))
        if label .startswith ("-"):
            raise EmailSyntaxError (start_descr .format ("hyphen"))
        if ".-"in label or "-."in label :
            raise EmailSyntaxError ("An email address cannot have a period and a hyphen next to each other.")


def uts46_valid_char (char :str )->bool :




    c =ord (char )
    if 0x80 <=c <=0x9f :

        return False 
    elif ((0x2010 <=c <=0x2060 and not (0x2024 <=c <=0x2026 )and not (0x2028 <=c <=0x202E ))
    or c in (0x00AD ,0x2064 ,0xFF0E )
    or 0x200B <=c <=0x200D 
    or 0x1BCA0 <=c <=0x1BCA3 ):


        return True 
    elif unicodedata .category (chr (c ))in ("Cf","Cn","Co","Cs","Zs","Zl","Zp"):






        return False 
    elif "002E"in unicodedata .decomposition (chr (c )).split (" "):

        return False 
    return True 


class DomainNameValidationResult (TypedDict ):
    ascii_domain :str 
    domain :str 


def validate_email_domain_name (domain :str ,test_environment :bool =False ,globally_deliverable :bool =True )->DomainNameValidationResult :
    """Validates the syntax of the domain part of an email address."""



    bad_chars ={
    safe_character_display (c )
    for c in domain 
    if not ATEXT_HOSTNAME_INTL .match (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The part after the @-sign contains invalid characters: "+", ".join (sorted (bad_chars ))+".")





    check_unsafe_chars (domain )



    bad_chars ={
    safe_character_display (c )for c in domain 
    if not uts46_valid_char (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The part after the @-sign contains invalid characters: "+", ".join (sorted (bad_chars ))+".")









    original_domain =domain 
    try :
        domain =idna .uts46_remap (domain ,std3_rules =False ,transitional =False )
    except idna .IDNAError as e :
        raise EmailSyntaxError (f"The part after the @-sign contains invalid characters ({e}).")from e 



    bad_chars ={
    safe_character_display (c )
    for c in domain 
    if not ATEXT_HOSTNAME_INTL .match (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The part after the @-sign contains invalid characters after Unicode normalization: "+", ".join (sorted (bad_chars ))+".")








    check_dot_atom (domain ,'An email address cannot have a {} immediately after the @-sign.','An email address cannot end with a {}.',is_hostname =True )



    for label in domain .split ("."):
        if re .match (r"(?!xn)..--",label ,re .I ):
            raise EmailSyntaxError ("An email address cannot have two letters followed by two dashes immediately after the @-sign or after a period, except Punycode.")

    if DOT_ATOM_TEXT_HOSTNAME .match (domain ):

        ascii_domain =domain 
    else :













        try :
            ascii_domain =".".join (
            idna .alabel (label ).decode ("ascii")
            for label in domain .split (".")
            )
        except idna .IDNAError as e :

            raise EmailSyntaxError (f"The part after the @-sign is invalid ({e}).")from e 



        if not DOT_ATOM_TEXT_HOSTNAME .match (ascii_domain ):
            raise EmailSyntaxError ("The email address contains invalid characters after the @-sign after IDNA encoding.")








    if len (ascii_domain )>DOMAIN_MAX_LENGTH :
        if ascii_domain ==original_domain :
            reason =get_length_reason (ascii_domain ,limit =DOMAIN_MAX_LENGTH )
            raise EmailSyntaxError (f"The email address is too long after the @-sign {reason}.")
        else :
            diff =len (ascii_domain )-DOMAIN_MAX_LENGTH 
            s =""if diff ==1 else "s"
            raise EmailSyntaxError (f"The email address is too long after the @-sign ({diff} byte{s} too many after IDNA encoding).")



    for label in ascii_domain .split ("."):
        if len (label )>DNS_LABEL_LENGTH_LIMIT :
            reason =get_length_reason (label ,limit =DNS_LABEL_LENGTH_LIMIT )
            raise EmailSyntaxError (f"After the @-sign, periods cannot be separated by so many characters {reason}.")

    if globally_deliverable :







        if "."not in ascii_domain and not (ascii_domain =="test"and test_environment ):
            raise EmailSyntaxError ("The part after the @-sign is not valid. It should have a period.")


        if not DOMAIN_NAME_REGEX .search (ascii_domain ):
            raise EmailSyntaxError ("The part after the @-sign is not valid. It is not within a valid top-level domain.")





    from .import SPECIAL_USE_DOMAIN_NAMES 
    for d in SPECIAL_USE_DOMAIN_NAMES :

        if d =="test"and test_environment :
            continue 

        if ascii_domain ==d or ascii_domain .endswith ("."+d ):
            raise EmailSyntaxError ("The part after the @-sign is a special-use or reserved name that cannot be used with email.")









    try :
        domain_i18n =idna .decode (ascii_domain .encode ('ascii'))
    except idna .IDNAError as e :
        raise EmailSyntaxError (f"The part after the @-sign is not valid IDNA ({e}).")from e 










    bad_chars ={
    safe_character_display (c )
    for c in domain_i18n 
    if not ATEXT_HOSTNAME_INTL .match (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The part after the @-sign contains invalid characters: "+", ".join (sorted (bad_chars ))+".")
    check_unsafe_chars (domain_i18n )



    try :
        idna .encode (domain_i18n )
    except idna .IDNAError as e :
        raise EmailSyntaxError (f"The part after the @-sign became invalid after normalizing to international characters ({e}).")from e 







    return {
    "ascii_domain":ascii_domain ,
    "domain":domain_i18n ,
    }


def validate_email_length (addrinfo :ValidatedEmail )->None :























    addresses_to_check =[
    (addrinfo .original ,None ),
    (addrinfo .normalized ,"after normalization"),
    ((addrinfo .ascii_local_part or addrinfo .local_part or "")+"@"+addrinfo .ascii_domain ,"when the part after the @-sign is converted to IDNA ASCII"),
    ]

    for addr ,reason in addresses_to_check :
        addr_len =len (addr )
        addr_utf8_len =len (addr .encode ("utf8"))
        diff =addr_utf8_len -EMAIL_MAX_LENGTH 
        if diff >0 :
            if reason is None and addr_len ==addr_utf8_len :



                reason =get_length_reason (addr ,limit =EMAIL_MAX_LENGTH )
            elif reason is None :






                mbpc =max (len (c .encode ("utf8"))for c in addr )
                mchars =max (1 ,diff //mbpc )
                suffix ="s"if diff >1 else ""
                if mchars ==diff :
                    reason =f"({diff} character{suffix} too many)"
                else :
                    reason =f"({mchars}-{diff} character{suffix} too many)"
            else :



                suffix ="s"if diff >1 else ""
                reason +=f" ({diff} byte{suffix} too many)"
            raise EmailSyntaxError (f"The email address is too long {reason}.")


class DomainLiteralValidationResult (TypedDict ):
    domain_address :Union [ipaddress .IPv4Address ,ipaddress .IPv6Address ]
    domain :str 


def validate_email_domain_literal (domain_literal :str )->DomainLiteralValidationResult :




    addr :Union [ipaddress .IPv4Address ,ipaddress .IPv6Address ]




    if re .match (r"^[0-9\.]+$",domain_literal ):
        try :
            addr =ipaddress .IPv4Address (domain_literal )
        except ValueError as e :
            raise EmailSyntaxError (f"The address in brackets after the @-sign is not valid: It is not an IPv4 address ({e}) or is missing an address literal tag.")from e 


        return {
        "domain_address":addr ,
        "domain":f"[{addr}]",
        }


    if domain_literal .startswith ("IPv6:"):
        try :
            addr =ipaddress .IPv6Address (domain_literal [5 :])
        except ValueError as e :
            raise EmailSyntaxError (f"The IPv6 address in brackets after the @-sign is not valid ({e}).")from e 



        return {
        "domain_address":addr ,
        "domain":f"[IPv6:{addr.compressed}]",
        }



    if ":"not in domain_literal :
        raise EmailSyntaxError ("The part after the @-sign in brackets is not an IPv4 address and has no address literal tag.")







    bad_chars ={
    safe_character_display (c )
    for c in domain_literal 
    if not DOMAIN_LITERAL_CHARS .match (c )
    }
    if bad_chars :
        raise EmailSyntaxError ("The part after the @-sign contains invalid characters in brackets: "+", ".join (sorted (bad_chars ))+".")



    raise EmailSyntaxError ("The part after the @-sign contains an invalid address literal tag in brackets.")
