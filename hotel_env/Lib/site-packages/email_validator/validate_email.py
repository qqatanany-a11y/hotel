from typing import Optional ,Union ,TYPE_CHECKING 
import unicodedata 

from .exceptions import EmailSyntaxError 
from .types import ValidatedEmail 
from .syntax import split_email ,validate_email_local_part ,validate_email_domain_name ,validate_email_domain_literal ,validate_email_length 
from .rfc_constants import CASE_INSENSITIVE_MAILBOX_NAMES 

if TYPE_CHECKING :
    import dns .resolver 
    _Resolver =dns .resolver .Resolver 
else :
    _Resolver =object 


def validate_email (
email :Union [str ,bytes ],
/,
*,
allow_smtputf8 :Optional [bool ]=None ,
allow_empty_local :Optional [bool ]=None ,
allow_quoted_local :Optional [bool ]=None ,
allow_domain_literal :Optional [bool ]=None ,
allow_display_name :Optional [bool ]=None ,
strict :Optional [bool ]=None ,
check_deliverability :Optional [bool ]=None ,
test_environment :Optional [bool ]=None ,
globally_deliverable :Optional [bool ]=None ,
timeout :Optional [int ]=None ,
dns_resolver :Optional [_Resolver ]=None 
)->ValidatedEmail :
    """
    Given an email address, and some options, returns a ValidatedEmail instance
    with information about the address if it is valid or, if the address is not
    valid, raises an EmailNotValidError. This is the main function of the module.
    """


    from .import ALLOW_SMTPUTF8 ,ALLOW_EMPTY_LOCAL ,ALLOW_QUOTED_LOCAL ,ALLOW_DOMAIN_LITERAL ,ALLOW_DISPLAY_NAME ,STRICT ,GLOBALLY_DELIVERABLE ,CHECK_DELIVERABILITY ,TEST_ENVIRONMENT ,DEFAULT_TIMEOUT 
    if allow_smtputf8 is None :
        allow_smtputf8 =ALLOW_SMTPUTF8 
    if allow_empty_local is None :
        allow_empty_local =ALLOW_EMPTY_LOCAL 
    if allow_quoted_local is None :
        allow_quoted_local =ALLOW_QUOTED_LOCAL 
    if allow_domain_literal is None :
        allow_domain_literal =ALLOW_DOMAIN_LITERAL 
    if allow_display_name is None :
        allow_display_name =ALLOW_DISPLAY_NAME 
    if strict is None :
        strict =STRICT 
    if check_deliverability is None :
        check_deliverability =CHECK_DELIVERABILITY 
    if test_environment is None :
        test_environment =TEST_ENVIRONMENT 
    if globally_deliverable is None :
        globally_deliverable =GLOBALLY_DELIVERABLE 
    if timeout is None and dns_resolver is None :
        timeout =DEFAULT_TIMEOUT 

    if isinstance (email ,str ):
        pass 
    elif isinstance (email ,bytes ):



        try :
            email =email .decode ("ascii")
        except ValueError as e :
            raise EmailSyntaxError ("The email address is not valid ASCII.")from e 
    else :
        raise TypeError ("email must be str or bytes")






    display_name ,local_part ,domain_part ,is_quoted_local_part =split_email (email )

    if display_name :





        display_name =unicodedata .normalize ("NFC",display_name )


    ret =ValidatedEmail ()
    ret .original =((local_part if not is_quoted_local_part 
    else ('"'+local_part +'"'))
    +"@"+domain_part )
    ret .display_name =display_name 





    local_part_info =validate_email_local_part (local_part ,
    allow_smtputf8 =allow_smtputf8 ,
    allow_empty_local =allow_empty_local ,
    quoted_local_part =is_quoted_local_part ,
    strict =strict )
    ret .local_part =local_part_info ["local_part"]
    ret .ascii_local_part =local_part_info ["ascii_local_part"]
    ret .smtputf8 =local_part_info ["smtputf8"]













    normalized_local_part =unicodedata .normalize ("NFC",ret .local_part )
    if normalized_local_part !=ret .local_part :
        try :
            validate_email_local_part (normalized_local_part ,
            allow_smtputf8 =allow_smtputf8 ,
            allow_empty_local =allow_empty_local ,
            quoted_local_part =is_quoted_local_part ,
            strict =strict )
        except EmailSyntaxError as e :
            raise EmailSyntaxError ("After Unicode normalization: "+str (e ))from e 
        ret .local_part =normalized_local_part 




    if is_quoted_local_part and not allow_quoted_local :
        raise EmailSyntaxError ("Quoting the part before the @-sign is not allowed here.")




    if ret .ascii_local_part is not None and ret .ascii_local_part .lower ()in CASE_INSENSITIVE_MAILBOX_NAMES and ret .local_part is not None :
        ret .ascii_local_part =ret .ascii_local_part .lower ()
        ret .local_part =ret .local_part .lower ()


    is_domain_literal =False 
    if len (domain_part )==0 :
        raise EmailSyntaxError ("There must be something after the @-sign.")

    elif domain_part .startswith ("[")and domain_part .endswith ("]"):

        domain_literal_info =validate_email_domain_literal (domain_part [1 :-1 ])
        if not allow_domain_literal :
            raise EmailSyntaxError ("A bracketed IP address after the @-sign is not allowed here.")
        ret .domain =domain_literal_info ["domain"]
        ret .ascii_domain =domain_literal_info ["domain"]
        ret .domain_address =domain_literal_info ["domain_address"]
        is_domain_literal =True 

    else :


        domain_name_info =validate_email_domain_name (domain_part ,test_environment =test_environment ,globally_deliverable =globally_deliverable )
        ret .domain =domain_name_info ["domain"]
        ret .ascii_domain =domain_name_info ["ascii_domain"]


    ret .normalized =ret .local_part +"@"+ret .domain 


    if not ret .smtputf8 :
        if not ret .ascii_domain :
            raise Exception ("Missing ASCII domain.")
        ret .ascii_email =(ret .ascii_local_part or "")+"@"+ret .ascii_domain 
    else :
        ret .ascii_email =None 


    validate_email_length (ret )



    if display_name is not None and not allow_display_name :
        raise EmailSyntaxError ("A display name and angle brackets around the email address are not permitted here.")

    if check_deliverability and not test_environment :



        if is_domain_literal :

            return ret 


        from .deliverability import validate_email_deliverability 
        deliverability_info =validate_email_deliverability (
        ret .ascii_domain ,ret .domain ,timeout ,dns_resolver 
        )
        mx =deliverability_info .get ("mx")
        if mx is not None :
            ret .mx =mx 
        ret .mx_fallback_type =deliverability_info .get ("mx_fallback_type")

    return ret 
