import inspect 
import os 
from importlib import import_module 

from django .core .exceptions import ImproperlyConfigured 
from django .utils .functional import cached_property 
from django .utils .module_loading import import_string ,module_has_submodule 

APPS_MODULE_NAME ="apps"
MODELS_MODULE_NAME ="models"


class AppConfig :
    """Class representing a Django application and its configuration."""

    def __init__ (self ,app_name ,app_module ):

        self .name =app_name 



        self .module =app_module 



        self .apps =None 






        if not hasattr (self ,"label"):
            self .label =app_name .rpartition (".")[2 ]
        if not self .label .isidentifier ():
            raise ImproperlyConfigured (
            "The app label '%s' is not a valid Python identifier."%self .label 
            )


        if not hasattr (self ,"verbose_name"):
            self .verbose_name =self .label .title ()



        if not hasattr (self ,"path"):
            self .path =self ._path_from_module (app_module )




        self .models_module =None 



        self .models =None 

    def __repr__ (self ):
        return "<%s: %s>"%(self .__class__ .__name__ ,self .label )

    @cached_property 
    def default_auto_field (self ):
        from django .conf import settings 

        return settings .DEFAULT_AUTO_FIELD 

    @property 
    def _is_default_auto_field_overridden (self ):
        return self .__class__ .default_auto_field is not AppConfig .default_auto_field 

    def _path_from_module (self ,module ):
        """Attempt to determine app's filesystem path from its module."""



        paths =list (getattr (module ,"__path__",[]))
        if len (paths )!=1 :
            filename =getattr (module ,"__file__",None )
            if filename is not None :
                paths =[os .path .dirname (filename )]
            else :


                paths =list (set (paths ))
        if len (paths )>1 :
            raise ImproperlyConfigured (
            "The app module %r has multiple filesystem locations (%r); "
            "you must configure this app with an AppConfig subclass "
            "with a 'path' class attribute."%(module ,paths )
            )
        elif not paths :
            raise ImproperlyConfigured (
            "The app module %r has no filesystem location, "
            "you must configure this app with an AppConfig subclass "
            "with a 'path' class attribute."%module 
            )
        return paths [0 ]

    @classmethod 
    def create (cls ,entry ):
        """
        Factory that creates an app config from an entry in INSTALLED_APPS.
        """

        app_config_class =None 
        app_name =None 
        app_module =None 


        try :
            app_module =import_module (entry )
        except Exception :
            pass 
        else :






            if module_has_submodule (app_module ,APPS_MODULE_NAME ):
                mod_path ="%s.%s"%(entry ,APPS_MODULE_NAME )
                mod =import_module (mod_path )


                app_configs =[
                (name ,candidate )
                for name ,candidate in inspect .getmembers (mod ,inspect .isclass )
                if (
                issubclass (candidate ,cls )
                and candidate is not cls 
                and getattr (candidate ,"default",True )
                )
                ]
                if len (app_configs )==1 :
                    app_config_class =app_configs [0 ][1 ]
                else :


                    app_configs =[
                    (name ,candidate )
                    for name ,candidate in app_configs 
                    if getattr (candidate ,"default",False )
                    ]
                    if len (app_configs )>1 :
                        candidates =[repr (name )for name ,_ in app_configs ]
                        raise RuntimeError (
                        "%r declares more than one default AppConfig: "
                        "%s."%(mod_path ,", ".join (candidates ))
                        )
                    elif len (app_configs )==1 :
                        app_config_class =app_configs [0 ][1 ]


            if app_config_class is None :
                app_config_class =cls 
                app_name =entry 


        if app_config_class is None :
            try :
                app_config_class =import_string (entry )
            except Exception :
                pass 


        if app_module is None and app_config_class is None :



            mod_path ,_ ,cls_name =entry .rpartition (".")
            if mod_path and cls_name [0 ].isupper ():





                mod =import_module (mod_path )
                candidates =[
                repr (name )
                for name ,candidate in inspect .getmembers (mod ,inspect .isclass )
                if issubclass (candidate ,cls )and candidate is not cls 
                ]
                msg ="Module '%s' does not contain a '%s' class."%(
                mod_path ,
                cls_name ,
                )
                if candidates :
                    msg +=" Choices are: %s."%", ".join (candidates )
                raise ImportError (msg )
            else :

                import_module (entry )



        if not issubclass (app_config_class ,AppConfig ):
            raise ImproperlyConfigured ("'%s' isn't a subclass of AppConfig."%entry )



        if app_name is None :
            try :
                app_name =app_config_class .name 
            except AttributeError :
                raise ImproperlyConfigured ("'%s' must supply a name attribute."%entry )


        try :
            app_module =import_module (app_name )
        except ImportError :
            raise ImproperlyConfigured (
            "Cannot import '%s'. Check that '%s.%s.name' is correct."
            %(
            app_name ,
            app_config_class .__module__ ,
            app_config_class .__qualname__ ,
            )
            )


        return app_config_class (app_name ,app_module )

    def get_model (self ,model_name ,require_ready =True ):
        """
        Return the model with the given case-insensitive model_name.

        Raise LookupError if no model exists with this name.
        """
        if require_ready :
            self .apps .check_models_ready ()
        else :
            self .apps .check_apps_ready ()
        try :
            return self .models [model_name .lower ()]
        except KeyError :
            raise LookupError (
            "App '%s' doesn't have a '%s' model."%(self .label ,model_name )
            )

    def get_models (self ,include_auto_created =False ,include_swapped =False ):
        """
        Return an iterable of models.

        By default, the following models aren't included:

        - auto-created models for many-to-many relations without
          an explicit intermediate table,
        - models that have been swapped out.

        Set the corresponding keyword argument to True to include such models.
        Keyword arguments aren't documented; they're a private API.
        """
        self .apps .check_models_ready ()
        for model in self .models .values ():
            if model ._meta .auto_created and not include_auto_created :
                continue 
            if model ._meta .swapped and not include_swapped :
                continue 
            yield model 

    def import_models (self ):


        self .models =self .apps .all_models [self .label ]

        if module_has_submodule (self .module ,MODELS_MODULE_NAME ):
            models_module_name ="%s.%s"%(self .name ,MODELS_MODULE_NAME )
            self .models_module =import_module (models_module_name )

    def ready (self ):
        """
        Override this method in subclasses to run code when Django starts.
        """
